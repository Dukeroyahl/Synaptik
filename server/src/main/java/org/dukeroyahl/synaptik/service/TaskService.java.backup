package org.dukeroyahl.synaptik.service;

import org.dukeroyahl.synaptik.domain.Task;
import org.dukeroyahl.synaptik.domain.TaskStatus;
import org.dukeroyahl.synaptik.domain.Project;
import org.dukeroyahl.synaptik.helper.TaskSearchQueryBuilder;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import io.smallrye.mutiny.Uni;
import org.jboss.logging.Logger;
import org.bson.Document;

import java.time.*;
import java.util.*;
import java.util.stream.Collectors;

@ApplicationScoped
public class TaskService {
    
    @Inject
    Logger logger;
    
    @Inject
    ProjectService projectService;
    
    @Inject
    TaskSearchQueryBuilder queryBuilder;
    
    public Uni<List<Task>> getAllTasks() {
        return Task.<Task>listAll()
            .onItem().transformToUni(this::enrichTasksWithProjects);
    }

    public Uni<List<Task>> getTasksByStatuses(List<TaskStatus> statuses) {
        if (statuses == null || statuses.isEmpty()) {
            return getAllTasks();
        }
        return Task.<Task>find("status in ?1", statuses).list()
            .onItem().transformToUni(this::enrichTasksWithProjects);
    }
    
    public Uni<Task> getTaskById(UUID id) {
        return Task.<Task>find("_id", id).firstResult()
            .onItem().transformToUni(this::enrichTaskWithProject);
    }
    
    public Uni<Task> createTask(Task task) {
        task.prePersist();
        task.urgency = task.calculateUrgency();
        logger.infof("Creating new task: %s", task.title);
        return task.persist()
            .onItem().transformToUni(persistedEntity -> {
                Task createdTask = (Task) persistedEntity;
                // Update project status after task creation
                if (createdTask.projectId != null) {
                    return projectService.updateProjectStatusBasedOnTasks(createdTask.projectId)
                        .onItem().transformToUni(project2 -> 
                            enrichTaskWithProject(createdTask)
                        );
                } else {
                    return enrichTaskWithProject(createdTask);
                }
            });
    }
    
    /**
     * Create a task with project name (for API use).
     * This method handles project auto-creation based on project name.
     */
    public Uni<Task> createTaskWithProject(Task task, String projectName) {
        // Handle project auto-creation if project name is provided
        if (projectName != null && !projectName.trim().isEmpty()) {
            return projectService.findOrCreateProject(projectName.trim())
                .onItem().transformToUni(project -> {
                    if (project != null) {
                        task.projectId = project.id;
                    }
                    return createTask(task);
                });
        } else {
            return createTask(task);
        }
    }
    
    public Uni<Task> updateTask(UUID id, Task updates) {
        return Task.<Task>find("_id", id).firstResult()
            .onItem().ifNotNull().transformToUni(task -> {
                updateTaskFields(task, updates);
                task.urgency = task.calculateUrgency();
                task.prePersist();
                logger.infof("Updating task: %s", task.title);
                return task.persistOrUpdate()
                    .onItem().transformToUni(persistedEntity -> {
                        Task updatedTask = (Task) persistedEntity;
                        // Update project status after task update
                        if (updatedTask.projectId != null) {
                            return projectService.updateProjectStatusBasedOnTasks(updatedTask.projectId)
                                .onItem().transformToUni(proj -> 
                                    enrichTaskWithProject(updatedTask)
                                );
                        } else {
                            return enrichTaskWithProject(updatedTask);
                        }
                    });
            });
    }
    
    /**
     * Update a task with project name (for API use).
     * This method handles project auto-creation based on project name.
     */
    public Uni<Task> updateTaskWithProject(UUID id, Task updates, String projectName) {
        return Task.<Task>find("_id", id).firstResult()
            .onItem().ifNotNull().transformToUni(task -> {
                // Handle project update if project name is provided
                if (projectName != null && !projectName.trim().isEmpty()) {
                    return projectService.findOrCreateProject(projectName.trim())
                        .onItem().transformToUni(project -> {
                            if (project != null) {
                                task.projectId = project.id;
                            }
                            return updateTask(id, updates);
                        });
                } else {
                    return updateTask(id, updates);
                }
            });
    }
    
    public Uni<Boolean> deleteTask(UUID id) {
        return Task.<Task>find("_id", id).firstResult()
            .onItem().ifNotNull().transformToUni(task -> {
                UUID projectId = task.projectId; // Store project ID before deletion
                logger.infof("Deleting task: %s", task.title);
                return task.delete()
                    .onItem().transformToUni(v -> {
                        // Update project status after task deletion
                        if (projectId != null) {
                            return projectService.updateProjectStatusBasedOnTasks(projectId)
                                .onItem().transform(project -> true);
                        } else {
                            return Uni.createFrom().item(true);
                        }
                    });
            })
            .onItem().ifNull().continueWith(false);
    }
    
    public Uni<Void> deleteAllTasks() {
        logger.info("Deleting all tasks");
        return Task.deleteAll().replaceWithVoid();
    }
    
    public Uni<Task> startTask(UUID id) {
        return Task.<Task>find("_id", id).firstResult()
            .onItem().ifNotNull().transformToUni(task -> {
                task.start();
                task.urgency = task.calculateUrgency();
                task.prePersist();
                
                return task.persistOrUpdate()
                    .onItem().transformToUni(persistedEntity -> {
                        Task updatedTask = (Task) persistedEntity;
                        // Auto-update project status if task belongs to a project
                        if (updatedTask.projectId != null) {
                            return projectService.updateProjectStatusBasedOnTasks(updatedTask.projectId)
                                .onItem().transformToUni(project -> 
                                    enrichTaskWithProject(updatedTask)
                                );
                        } else {
                            return enrichTaskWithProject(updatedTask);
                        }
                    });
            });
    }
    
    public Uni<Task> stopTask(UUID id) {
        return Task.<Task>find("_id", id).firstResult()
            .onItem().ifNotNull().transformToUni(task -> {
                task.stop();
                task.urgency = task.calculateUrgency();
                task.prePersist();
                
                return task.persistOrUpdate()
                    .onItem().transformToUni(persistedEntity -> {
                        Task updatedTask = (Task) persistedEntity;
                        // Auto-update project status if task belongs to a project
                        if (updatedTask.projectId != null) {
                            return projectService.updateProjectStatusBasedOnTasks(updatedTask.projectId)
                                .onItem().transformToUni(project -> 
                                    enrichTaskWithProject(updatedTask)
                                );
                        } else {
                            return enrichTaskWithProject(updatedTask);
                        }
                    });
            });
    }
    
    public Uni<Task> markTaskDone(UUID id) {
        return Task.<Task>find("_id", id).firstResult()
            .onItem().ifNotNull().transformToUni(task -> {
                task.done();
                task.urgency = task.calculateUrgency();
                task.prePersist();
                
                return task.persistOrUpdate()
                    .onItem().transformToUni(persistedEntity -> {
                        Task updatedTask = (Task) persistedEntity;
                        // Auto-update project status if task belongs to a project
                        if (updatedTask.projectId != null) {
                            return projectService.updateProjectStatusBasedOnTasks(updatedTask.projectId)
                                .onItem().transformToUni(project -> 
                                    enrichTaskWithProject(updatedTask)
                                );
                        } else {
                            return enrichTaskWithProject(updatedTask);
                        }
                    });
            });
    }
    
    public Uni<List<Task>> getTasksByStatus(TaskStatus status) {
        return Task.<Task>find("status", status).list()
            .onItem().transformToUni(this::enrichTasksWithProjects);
    }
    
    public Uni<List<Task>> getOverdueTasks(String tz) {
        ZoneId zone = resolveZone(tz);
        ZonedDateTime now = ZonedDateTime.now(zone);
        List<TaskStatus> statuses = List.of(TaskStatus.PENDING, TaskStatus.ACTIVE, TaskStatus.COMPLETED);
        return Task.<Task>find("status in ?1", statuses).list()
            .onItem().transform(list -> list.stream()
                .filter(t -> isOverdue(t, now))
                .collect(Collectors.toList()))
            .onItem().transformToUni(this::enrichTasksWithProjects);
    }

    public Uni<List<Task>> getTodayTasks(String tz) {
        ZoneId zone = resolveZone(tz);
        LocalDate today = LocalDate.now(zone);
        List<TaskStatus> statuses = List.of(TaskStatus.PENDING, TaskStatus.ACTIVE, TaskStatus.COMPLETED);
        return Task.<Task>find("status in ?1", statuses).list()
            .onItem().transform(list -> list.stream()
                .filter(t -> isDueToday(t, today, zone))
                .collect(Collectors.toList()))
            .onItem().transformToUni(this::enrichTasksWithProjects);
    }

    // Project enrichment methods
    private Uni<Task> enrichTaskWithProject(Task task) {
        if (task == null || task.projectId == null) {
            return Uni.createFrom().item(task);
        }
        
        return projectService.getProjectById(task.projectId)
            .onItem().transform(project -> {
                task.projectDetails = project;
                return task;
            });
    }
    
    private Uni<List<Task>> enrichTasksWithProjects(List<Task> tasks) {
        if (tasks == null || tasks.isEmpty()) {
            return Uni.createFrom().item(tasks);
        }
        
        // Get all unique project IDs
        Set<UUID> projectIds = tasks.stream()
            .map(task -> task.projectId)
            .filter(Objects::nonNull)
            .collect(Collectors.toSet());
        
        if (projectIds.isEmpty()) {
            return Uni.createFrom().item(tasks);
        }
        
        // Fetch all projects in one query
        return Project.<Project>find("_id in ?1", projectIds).list()
            .onItem().transform(projects -> {
                // Create a map for quick lookup
                Map<UUID, Project> projectMap = projects.stream()
                    .collect(Collectors.toMap(p -> p.id, p -> p));
                
                // Enrich tasks with project details
                tasks.forEach(task -> {
                    if (task.projectId != null) {
                        task.projectDetails = projectMap.get(task.projectId);
                    }
                });
                
                return tasks;
            });
    }

    private ZoneId resolveZone(String tz) {
        try {
            if (tz != null && !tz.isBlank()) return ZoneId.of(tz);
        } catch (Exception ignored) {}
        return ZoneId.systemDefault();
    }

    private boolean isOverdue(Task t, ZonedDateTime now) {
        if (t.dueDate == null || t.dueDate.isBlank()) return false;
        ZonedDateTime due = parseDueDate(t.dueDate, now.getZone(), true);
        return due != null && due.isBefore(now);
    }

    private boolean isDueToday(Task t, LocalDate today, ZoneId zone) {
        if (t.dueDate == null || t.dueDate.isBlank()) return false;
        ZonedDateTime due = parseDueDate(t.dueDate, zone, false);
        return due != null && due.toLocalDate().equals(today);
    }

    private ZonedDateTime parseDueDate(String raw, ZoneId zone, boolean endOfDayForDateOnly) {
        try {
            // Try ZonedDateTime first
            return ZonedDateTime.parse(raw);
        } catch (Exception ignored) {}
        try {
            // Try LocalDateTime
            LocalDateTime ldt = LocalDateTime.parse(raw);
            return ldt.atZone(zone);
        } catch (Exception ignored) {}
        try {
            // Try LocalDate
            LocalDate ld = LocalDate.parse(raw);
            if (endOfDayForDateOnly) {
                return ld.atTime(23,59,59,999_000_000).atZone(zone);
            }
            return ld.atStartOfDay(zone);
        } catch (Exception ignored) {}
        return null;
    }
    
    /**
     * Search tasks with database-level filtering using project UUID only.
     * Uses TaskSearchQueryBuilder helper class for clean separation of concerns.
     * 
     * @param statuses List of task statuses to filter by (optional)
     * @param title Partial title search (optional, case-insensitive)
     * @param assignee Partial assignee search (optional, case-insensitive)
     * @param projectId Project UUID for exact matching (optional)
     * @param dateFrom Start date for due date range filter (optional, ISO format)
     * @param dateTo End date for due date range filter (optional, ISO format)
     * @param timezone Timezone for date range filtering (default: UTC)
     * @return List of tasks matching the search criteria
     */
    public Uni<List<Task>> searchTasks(List<TaskStatus> statuses, String title, String assignee, 
                                      String projectId, String dateFrom, String dateTo, String timezone) {
        logger.infof("Searching tasks with database-level filters - statuses: %s, title: %s, assignee: %s, projectId: %s, dateFrom: %s, dateTo: %s, timezone: %s", 
                    statuses, title, assignee, projectId, dateFrom, dateTo, timezone);
        
        // Use helper class to build MongoDB query
        Document query = queryBuilder.buildSearchQuery(statuses, title, assignee, projectId, dateFrom, dateTo, timezone);
        
        // Execute database query with filters applied at DB level
        return Task.<Task>find(query).list()
            .onItem().transformToUni(this::enrichTasksWithProjects);
    }
    
    /**
     * Build MongoDB query document based on search filters.
     * Simplified since we only handle project UUID now.
     */
    private Document buildSearchQuery(List<TaskStatus> statuses, String title, String assignee, 
                                     String projectId, String dateFrom, String dateTo, String timezone) {
        Document query = new Document();
        
        // Status filter - use $in operator for multiple statuses
        if (statuses != null && !statuses.isEmpty()) {
            if (statuses.size() == 1) {
                query.append("status", statuses.get(0).name());
            } else {
                List<String> statusStrings = statuses.stream()
                    .map(TaskStatus::name)
                    .collect(Collectors.toList());
                query.append("status", new Document("$in", statusStrings));
            }
        }
        
        // Title filter - case-insensitive regex
        if (title != null && !title.trim().isEmpty()) {
            String normalizedTitle = title.trim();
            query.append("title", new Document("$regex", Pattern.quote(normalizedTitle))
                .append("$options", "i")); // case-insensitive
        }
        
        // Assignee filter - case-insensitive regex
        if (assignee != null && !assignee.trim().isEmpty()) {
            String normalizedAssignee = assignee.trim();
            query.append("assignee", new Document("$regex", Pattern.quote(normalizedAssignee))
                .append("$options", "i")); // case-insensitive
        }
        
        // Project filter - exact UUID match only
        if (projectId != null && !projectId.trim().isEmpty()) {
            String trimmedProjectId = projectId.trim();
            
            if (isValidUUID(trimmedProjectId)) {
                try {
                    UUID projectUUID = UUID.fromString(trimmedProjectId);
                    query.append("projectId", projectUUID);
                } catch (IllegalArgumentException e) {
                    logger.warnf("Invalid project UUID format: %s", trimmedProjectId);
                    // Invalid UUID format, no results
                    query.append("_id", new Document("$exists", false)); // Force no results
                }
            } else {
                logger.warnf("Project ID is not a valid UUID format: %s", trimmedProjectId);
                // Not a UUID, no results
                query.append("_id", new Document("$exists", false)); // Force no results
            }
        }
        
        // Date range filter
        ZoneId zone = resolveZone(timezone);
        Document dateQuery = buildDateRangeQuery(dateFrom, dateTo, zone);
        if (dateQuery != null) {
            query.append("dueDate", dateQuery);
        }
        
        return query;
    }
    
    /**
     * Build MongoDB date range query.
     */
    private Document buildDateRangeQuery(String dateFrom, String dateTo, ZoneId zone) {
        if ((dateFrom == null || dateFrom.trim().isEmpty()) && 
            (dateTo == null || dateTo.trim().isEmpty())) {
            return null;
        }
        
        Document dateQuery = new Document();
        
        // Handle dateFrom
        if (dateFrom != null && !dateFrom.trim().isEmpty()) {
            ZonedDateTime fromDate = parseDateForRange(dateFrom.trim(), zone, true);
            if (fromDate != null) {
                // Convert to ISO string for MongoDB comparison
                dateQuery.append("$gte", fromDate.toInstant().toString());
            }
        }
        
        // Handle dateTo  
        if (dateTo != null && !dateTo.trim().isEmpty()) {
            ZonedDateTime toDate = parseDateForRange(dateTo.trim(), zone, false);
            if (toDate != null) {
                // Convert to ISO string for MongoDB comparison
                dateQuery.append("$lte", toDate.toInstant().toString());
            }
        }
        
        return dateQuery.isEmpty() ? null : dateQuery;
    }
    
    /**
     * Pre-process and validate status filters once.
     * Now much simpler since JAX-RS handles the enum conversion!
     */
    private Set<TaskStatus> parseValidStatuses(List<TaskStatus> statuses) {
        if (statuses == null || statuses.isEmpty()) {
            return null; // No filter applied
        }
        
        // JAX-RS already converted strings to enums and filtered out invalid ones
        // We just need to convert to Set for O(1) lookup performance
        return new HashSet<>(statuses);
    }
    
    /**
     * Normalize text for search (trim and lowercase once).
     * Returns null if no filter should be applied.
     */
    private String normalizeSearchText(String text) {
        if (text == null || text.trim().isEmpty()) {
            return null;
        }
        return text.trim().toLowerCase();
    }
    
    /**
     * Pre-process project filter to determine if it's a UUID or name search.
     */
    private ProjectFilter parseProjectFilter(String project) {
        if (project == null || project.trim().isEmpty()) {
            return null;
        }
        
        String trimmed = project.trim();
        
        if (isValidUUID(trimmed)) {
            try {
                UUID projectUUID = UUID.fromString(trimmed);
                return new ProjectFilter(projectUUID, null);
            } catch (IllegalArgumentException e) {
                // Fall through to name matching
            }
        }
        
        return new ProjectFilter(null, trimmed.toLowerCase());
    }
    
    /**
     * Pre-process date strings for range filtering.
     */
    private ZonedDateTime parseSearchDate(String dateStr, ZoneId zone, boolean startOfDay) {
        if (dateStr == null || dateStr.trim().isEmpty()) {
            return null;
        }
        return parseDateForRange(dateStr.trim(), zone, startOfDay);
    }
    
    /**
     * Optimized status filter - uses pre-processed Set for O(1) lookup.
     */
    private boolean matchesStatusFilter(Task task, Set<TaskStatus> validStatuses) {
        if (validStatuses == null) {
            return true; // No filter applied
        }
        
        if (validStatuses.isEmpty()) {
            return false; // All provided statuses were invalid
        }
        
        return validStatuses.contains(task.status);
    }
    
    /**
     * Optimized title filter - uses pre-normalized search text.
     */
    private boolean matchesTitleFilter(Task task, String normalizedTitle) {
        if (normalizedTitle == null) {
            return true; // No filter applied
        }
        
        if (task.title == null) {
            return false;
        }
        
        return task.title.toLowerCase().contains(normalizedTitle);
    }
    
    /**
     * Optimized assignee filter - uses pre-normalized search text.
     */
    private boolean matchesAssigneeFilter(Task task, String normalizedAssignee) {
        if (normalizedAssignee == null) {
            return true; // No filter applied
        }
        
        if (task.assignee == null) {
            return false;
        }
        
        return task.assignee.toLowerCase().contains(normalizedAssignee);
    }
    
    /**
     * Optimized project filter - uses pre-processed ProjectFilter object.
     */
    private boolean matchesProjectFilter(Task task, ProjectFilter projectFilter) {
        if (projectFilter == null) {
            return true; // No filter applied
        }
        
        // UUID match (exact)
        if (projectFilter.uuid != null) {
            return projectFilter.uuid.equals(task.projectId);
        }
        
        // Name match (partial, case-insensitive)
        if (projectFilter.normalizedName != null) {
            if (task.projectDetails == null || task.projectDetails.name == null) {
                return false;
            }
            return task.projectDetails.name.toLowerCase().contains(projectFilter.normalizedName);
        }
        
        return false;
    }
    
    /**
     * Optimized date range filter - uses pre-processed ZonedDateTime objects.
     */
    private boolean matchesDateRangeFilter(Task task, ZonedDateTime fromDate, ZonedDateTime toDate) {
        if (fromDate == null && toDate == null) {
            return true; // No date filter applied
        }
        
        if (task.dueDate == null || task.dueDate.trim().isEmpty()) {
            return false; // Task has no due date, can't match date range
        }
        
        ZonedDateTime taskDueDate = parseDueDate(task.dueDate, ZoneId.systemDefault(), false);
        if (taskDueDate == null) {
            return false; // Invalid task due date format
        }
        
        // Check dateFrom filter
        if (fromDate != null && taskDueDate.isBefore(fromDate)) {
            return false;
        }
        
        // Check dateTo filter
        if (toDate != null && taskDueDate.isAfter(toDate)) {
            return false;
        }
        
        return true;
    }
    
    /**
     * Helper class to hold pre-processed project filter information.
     */
    private static class ProjectFilter {
        final UUID uuid;
        final String normalizedName;
        
        ProjectFilter(UUID uuid, String normalizedName) {
            this.uuid = uuid;
            this.normalizedName = normalizedName;
        }
    }
    
    /**
     * Parse date for range filtering with proper timezone handling.
     * @param dateStr Date string to parse
     * @param zone Target timezone
     * @param startOfDay If true, returns start of day (00:00:00), otherwise end of day (23:59:59.999)
     * @return ZonedDateTime or null if parsing fails
     */
    private ZonedDateTime parseDateForRange(String dateStr, ZoneId zone, boolean startOfDay) {
        try {
            // Try ZonedDateTime first (already has timezone info)
            ZonedDateTime zdt = ZonedDateTime.parse(dateStr);
            return startOfDay ? zdt.withHour(0).withMinute(0).withSecond(0).withNano(0) 
                             : zdt.withHour(23).withMinute(59).withSecond(59).withNano(999_000_000);
        } catch (Exception ignored) {}
        
        try {
            // Try LocalDateTime (apply user's timezone)
            LocalDateTime ldt = LocalDateTime.parse(dateStr);
            ZonedDateTime zdt = ldt.atZone(zone);
            return startOfDay ? zdt.withHour(0).withMinute(0).withSecond(0).withNano(0)
                             : zdt.withHour(23).withMinute(59).withSecond(59).withNano(999_000_000);
        } catch (Exception ignored) {}
        
        try {
            // Try LocalDate (apply user's timezone)
            LocalDate ld = LocalDate.parse(dateStr);
            if (startOfDay) {
                return ld.atStartOfDay(zone);
            } else {
                return ld.atTime(23, 59, 59, 999_000_000).atZone(zone);
            }
        } catch (Exception ignored) {}
        
        logger.warnf("Unable to parse date: %s", dateStr);
        return null;
    }
    
    /**
     * Check if a string is a valid UUID format.
     */
    private boolean isValidUUID(String str) {
        if (str == null || str.length() != 36) {
            return false;
        }
        
        // Basic UUID format check: 8-4-4-4-12 characters with hyphens
        return str.matches("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$");
    }
    
    private void updateTaskFields(Task task, Task updates) {
        // Note: ID is never updated - UUIDs are immutable
        if (updates.title != null) task.title = updates.title;
        
        // For nullable fields, we need to distinguish between "not provided" vs "explicitly set to null"
        // Since we're using JSON serialization, null values are included in the updates object
        // We'll update these fields even when they're null to allow clearing them
        task.description = updates.description;
        task.assignee = updates.assignee;
        task.dueDate = updates.dueDate;
        task.waitUntil = updates.waitUntil;
        
        // Note: projectId is NOT updated here - it's handled by the project auto-creation logic
        // in the updateTask method above when the client provides a project name
        // Clients should not directly set projectId
        
        // Non-nullable fields should still check for null
        if (updates.status != null) task.status = updates.status;
        if (updates.priority != null) task.priority = updates.priority;
        if (updates.tags != null) task.tags = updates.tags;
        if (updates.depends != null) task.depends = updates.depends;
    }
}