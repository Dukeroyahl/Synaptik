import fs from 'fs';
import path from 'path';
import { promisify } from 'util';
import { exec } from 'child_process';
import { Task } from '../models';
import connectDB from '../database/mongodb';

const execPromise = promisify(exec);

interface TaskWarriorTask {
  id?: string;
  uuid: string;
  description: string;
  status: string;
  entry: string;
  modified?: string;
  due?: string;
  wait?: string;
  scheduled?: string;
  until?: string;
  annotations?: { description: string; entry: string }[];
  tags?: string[];
  priority?: string;
  project?: string;
  depends?: string | string[];
  urgency?: number;
  start?: string;
  end?: string;
}

/**
 * Convert TaskWarrior status to Synaptik status
 */
function convertStatus(twStatus: string): 'pending' | 'waiting' | 'active' | 'completed' | 'deleted' {
  switch (twStatus) {
    case 'pending':
      return 'pending';
    case 'waiting':
      return 'waiting';
    case 'completed':
      return 'completed';
    case 'deleted':
      return 'deleted';
    default:
      return 'pending';
  }
}

/**
 * Convert TaskWarrior priority to Synaptik priority
 */
function convertPriority(twPriority?: string): 'H' | 'M' | 'L' | '' {
  switch (twPriority) {
    case 'H':
      return 'H';
    case 'M':
      return 'M';
    case 'L':
      return 'L';
    default:
      return '';
  }
}

/**
 * Convert TaskWarrior date format to ISO string
 */
function convertDate(twDate?: string): string | undefined {
  if (!twDate) return undefined;
  
  // TaskWarrior uses Unix timestamps
  const timestamp = parseInt(twDate);
  if (isNaN(timestamp)) return undefined;
  
  return new Date(timestamp * 1000).toISOString();
}

/**
 * Parse TaskWarrior dependency UUIDs
 */
function parseDependencies(depends?: string | string[]): string[] {
  if (!depends) return [];
  
  // Handle array format (TaskWarrior sometimes exports dependencies as arrays)
  if (Array.isArray(depends)) {
    return depends;
  }
  
  // Handle string format (comma-separated UUIDs)
  if (typeof depends === 'string') {
    return depends.split(',');
  }
  
  // Handle unexpected format
  console.warn('Unexpected dependency format:', depends);
  return [];
}

/**
 * Convert TaskWarrior task to Synaptik task
 */
function convertTask(twTask: TaskWarriorTask): any {
  try {
    console.log(`Converting task: ${twTask.uuid} - ${twTask.description}`);
    
    const annotations = twTask.annotations?.map(anno => ({
      timestamp: convertDate(anno.entry) || new Date().toISOString(),
      description: anno.description
    })) || [];

    // Don't use the UUID as _id since MongoDB requires ObjectId format
    const task = {
      // _id is automatically generated by MongoDB
      title: twTask.description,
      description: '', // TaskWarrior doesn't have a separate description field
      status: convertStatus(twTask.status),
      priority: convertPriority(twTask.priority),
      urgency: twTask.urgency || 0,
      project: twTask.project,
      dueDate: convertDate(twTask.due),
      waitUntil: convertDate(twTask.wait),
      tags: twTask.tags || [],
      annotations: annotations,
      depends: parseDependencies(twTask.depends)
    };
    
    return task;
  } catch (error) {
    console.error(`Error converting task ${twTask.uuid}:`, error);
    console.error('Task data:', JSON.stringify(twTask, null, 2));
    throw error;
  }
}

/**
 * Export TaskWarrior data to JSON
 */
async function exportTaskWarriorData(): Promise<TaskWarriorTask[]> {
  try {
    // Use TaskWarrior's export command to get all tasks in JSON format
    const { stdout } = await execPromise('task export');
    
    try {
      const tasks = JSON.parse(stdout);
      console.log(`Successfully parsed ${tasks.length} tasks from TaskWarrior export`);
      
      // Log a sample task for debugging
      if (tasks.length > 0) {
        const sampleTask = tasks[0];
        console.log('Sample task structure:', JSON.stringify({
          uuid: sampleTask.uuid,
          description: sampleTask.description,
          status: sampleTask.status,
          depends: sampleTask.depends,
          tags: sampleTask.tags
        }, null, 2));
      }
      
      return tasks;
    } catch (parseError) {
      console.error('Error parsing TaskWarrior JSON output:', parseError);
      console.error('Raw output:', stdout);
      throw new Error('Failed to parse TaskWarrior export data');
    }
  } catch (error) {
    console.error('Error exporting TaskWarrior data:', error);
    throw error;
  }
}

/**
 * Import TaskWarrior tasks to MongoDB
 */
export async function importTasksFromTaskWarrior(): Promise<{ success: boolean; count: number; message: string }> {
  try {
    // Connect to MongoDB
    await connectDB();
    
    // Get TaskWarrior data
    const twTasks = await exportTaskWarriorData();
    console.log(`Found ${twTasks.length} tasks in TaskWarrior`);
    
    if (twTasks.length === 0) {
      return {
        success: true,
        count: 0,
        message: 'No tasks found in TaskWarrior'
      };
    }
    
    // Convert and import tasks
    const synaptikTasks = twTasks.map(convertTask);
    console.log(`Converted ${synaptikTasks.length} tasks to Synaptik format`);
    
    // Insert tasks one by one for better error handling
    let insertedCount = 0;
    for (const task of synaptikTasks) {
      try {
        await Task.create(task);
        insertedCount++;
      } catch (error: any) {
        console.error(`Error inserting task ${task._id}:`, error.message);
      }
    }
    
    console.log(`Inserted ${insertedCount} tasks into MongoDB`);
    
    return {
      success: true,
      count: insertedCount,
      message: `Successfully imported ${insertedCount} tasks from TaskWarrior`
    };
  } catch (error: any) {
    console.error('Error importing tasks:', error);
    
    // Handle duplicate key errors (some tasks might have been imported already)
    if (error.code === 11000 || (error.writeErrors && error.writeErrors.some((e: any) => e.code === 11000))) {
      return {
        success: false,
        count: 0,
        message: 'Some tasks already exist in the database. Try using the --force option to overwrite.'
      };
    }
    
    return {
      success: false,
      count: 0,
      message: `Error importing tasks: ${error.message}`
    };
  }
}

/**
 * Force import TaskWarrior tasks to MongoDB (delete existing tasks first)
 */
export async function forceImportTasksFromTaskWarrior(): Promise<{ success: boolean; count: number; message: string }> {
  try {
    // Connect to MongoDB
    await connectDB();
    
    // Delete all existing tasks
    await Task.deleteMany({});
    console.log('Deleted all existing tasks');
    
    // Import tasks
    return importTasksFromTaskWarrior();
  } catch (error: any) {
    console.error('Error force importing tasks:', error);
    return {
      success: false,
      count: 0,
      message: `Error force importing tasks: ${error.message}`
    };
  }
}

// If this file is run directly
if (require.main === module) {
  const force = process.argv.includes('--force');
  
  (force ? forceImportTasksFromTaskWarrior() : importTasksFromTaskWarrior())
    .then(result => {
      console.log(result.message);
      process.exit(result.success ? 0 : 1);
    })
    .catch(error => {
      console.error('Unhandled error:', error);
      process.exit(1);
    });
}
